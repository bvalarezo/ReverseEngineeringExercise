Bryan Valarezo
110362410

This is a write up reverse engineering the 2 binaries
-Number
-Key

## Number

After downloading the binary, I ran `file(1)` on it to get relevant information.

$ file ./number

> ./number: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=f8ca93addd368c65d626901f74c3c9eb79b8ec1a, stripped

What is important to note is that the binary is
-stripped
-32-bit Intel x86
-linked with a shared object

Running `ldd(1)` reveals that the shared object is libc
$ldd ./number

> linux-gate.so.1 (0xb7f1b000)
libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xb7d21000)
/lib/ld-linux.so.2 (0xb7f1c000)

Nothing quite interesting yet, I then ran `strings(1)` to find any interesting data in the binary.

$ strings ./number

This reveals some information.

libc functions...
fflush
exit
__isoc99_scanf
puts
stdin
printf
strlen
memset
atoi
strcmp

and some custom strings too...
Wrong number
Enter the right number:
%27s
CSE363ESC
Your number corresponds to %s, well done!    

If we run the binary normally...we can see some of these strings in action.

$ ./number 
Enter the right number: 12
Wrong number

I can run the binary with `strace(1)` and `ltrace(1)` to see which of the libc functions and syscalls were being called.

$ strace ./number
$ ltrace ./number

So far, I can guess that the program uses `scanf(3)` to read the number from STDIN. Then at the end, print the result of the comparasion via `printf(3)`. However, it isn't clear how the comparasion is done.

Lets actually look into the binary itself, with `objdump(1)`.

$ objdump -xd ./number

This reveals important information, such as

start address 0x000010e0 //beginning of .text
__libc_start_main: //Perhaps where main is
00001000 <.init> //the beginning of init

Which we can use as a breakpoint in a debugger.

Lets run this in a debugger like `gdb(1)` to grasp a better understanding

$ gdb ./number

AT&T syntax sucks, lets use Intel

> set disassembly-flavor intel

Trying to disassemble from main isn't so simple(Since the binary was stripped :/ ).

> disassemble main
No symbol table is loaded.  Use the "file" command.

However, we do know __libc_start_main exists, so lets set up a breakpoint there.

(gdb) break __libc_start_main
Breakpoint 1 at 0xb7dfe720: file ../csu/libc-start.c, line 141.

We have to find a better location for the breakpoint. Single stepping into scanf immediately exits...

Its time to whip out the big guns(Ghidra).

Ghidra is a very powerful tool that upon importing the binary, it found the function that called scanf and printf.

Now, all we need todo is to analyze the function to see what input will invoke the printf.

undefined4 FUN_00011251(void)

{
  size_t sVar1;
  int iVar2;
  undefined4 in_ECX;
  char local_66;
  char local_65;
  char local_64;
  undefined local_63;
  char local_62 [64];
  char local_22 [10];
  int local_18;
  int local_14;
  uint local_10;
  undefined4 local_c;
  
  local_c = in_ECX;
  printf("Enter the right number: ");
  local_18 = __isoc99_scanf(&DAT_0001202e,local_62);
  if (local_18 != 1) { //if scanf did not read 1 input(it failed)
    FUN_00011219(); 
  } 
  if (local_62[0] != '0') {
    FUN_00011219(); 
  }
  if (local_62[1] != '6') {
    FUN_00011219(); 
  }
  fflush(stdin);
  memset(local_22,0,10);
  local_63 = 0;
  local_10 = 0;
  local_14 = 0;
  while( true ) {
    sVar1 = strlen(local_22);
    if (8 < sVar1) break;
    sVar1 = strlen(local_62);
    if (sVar1 <= local_10) break;
    local_66 = local_62[local_10];
    local_65 = local_62[local_10 + 1];
    local_64 = local_62[local_10 + 2];
    iVar2 = atoi(&local_66);
    local_22[local_14] = (char)iVar2;
    local_22[local_14] = local_22[local_14] + '\x03';
    local_10 = local_10 + 3;
    local_14 = local_14 + 1;
  }
  local_22[local_14] = '\0';
  iVar2 = strcmp(local_22,"CSE363ESC");
  if (iVar2 == 0) {
    printf("Your number corresponds to %s, well done!\n",local_22);
  }
  else {
    FUN_00011219();
  }
  return 0;
}

Below is my simplified version

undefined4 crackme(void)

{
  size_t strlen_retval;
  int x_int;
  int strcmp_retval
  undefined4 in_ECX;
  char x;
  char y;//noise
  char z;//noise
  char input [64];
  char final_number [10];
  int scanf_retval;
  int c;
  uint b;
  undefined4 local_c;
  
  local_c = in_ECX;
  printf("Enter the right number: ");
  scanf_retval = __isoc99_scanf(&DAT_0001202e,input);
  if (scanf_retval != 1) {
    exit();
  }
  if (input[0] != '0') {
    exit();
  }
  if (input[1] != '6') {
    exit();
  }
  fflush(stdin);
  memset(final_number,0,10);
  b = 0;
  c = 0;
  while( true ) {
    strlen_retval = strlen(final_number); // returns 0 if '==', -1 for '<', 1 for '>'
    if (8 < strlen_retval)
    {
        break;
    }
    strlen_retval = strlen(input);
    if (strlen_retval <= b) 
    {
        break;
    }
    x = input[b]; //b = 0 ,3 ,6 ,9 ,12, 15, 18, 21, 24, 27, 30
    x_int = atoi(&x); //convert str `x` to ascii int
    final_number[c] = (char)x_int;
    final_number[c] = final_number[c] + '\x03'; // + 3
    b = b + 3; 
    c++;
  }
  //input = ['@',6, x,'P',x, x,'B',x,x,'0',x,x,'3',x,x,'0',x,x,'B',x,x,'P',x,x,'@',x,x]
  //final_number = [64, 80, 66, 48, 51, 48, 66, 80, 64, 0]
  final_number[c] = '\0';
  strcmp_retval = strcmp(final_number,"CSE363ESC"); //CSE363ESC ==> [67,83,69,51,54,51,69,83,67,'\0']
  if (strcmp_retval == 0) {
    printf("Your number corresponds to %s, well done!\n",final_number);
  }
  else {
    exit();
  }
  return 0;
}

